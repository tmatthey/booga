/*
 * CTCPPRenderer2D.C
 *
 * Copyright (C) 1994-96, Thomas Wenger
 *                        Thomas von Siebenthal
 *                        University of Berne, Switzerland
 *
 * All rights reserved.
 *
 * This software may be freely copied, modified, and redistributed
 * provided that this copyright notice is preserved on all copies.
 *
 * You may not distribute this software, in whole or in part, as part of
 * any commercial product without the express consent of the authors.
 *
 * There is no warranty or other guarantee of fitness of this software
 * for any purpose.  It is provided solely as is.
 *
 * -----------------------------------------------------------------------------
 *  $Id: CTCPPRenderer2D.C,v 1.19 1996/10/30 15:31:24 amann Exp $
 * -----------------------------------------------------------------------------
 */
#include <unistd.h> //getlogin
#include "booga/base/RCString.h"
#include "booga/base/List.h"
#include "booga/base/Report.h"
#include "booga/object/Object2D.h"
#include "booga/object/Shared2D.h"
#include "booga/component/CollectShared2D.h"
#include <iostream>
#include <fstream>
#include <time.h>
#include "CTCPPRenderer2D.h"
#include "CTAttributeDescription.h"

//____________________________________________________________ CTCPPRenderer2D

implementRTTI(CTCPPRenderer2D, Operation2D);



CTCPPRenderer2D::CTCPPRenderer2D(const RCString filename)
{
  myCurrentIdent = "";
  myIdent = "  ";

  // try to create file stream  
  myFileOutput = new std::ofstream(filename.chars());
  
  // filename was indicating STDOUT
  if ( (filename == "cout") || (filename == "stdout") || (filename == "") ) {
    delete myFileOutput;
    myOutput = &std::cout;
    }
  else {
    // filename was incorrect and creation of stream failed
    if (!myFileOutput) {
      Report::error("[CTCPPRenderer2D] could not open file " + filename);
      // delete myFileOutput;
      // myOutput = &cout;
      }
    else {
      // file stream is OK
      myOutput = myFileOutput;
      }
    }; 

   *myOutput << "//\n";
   *myOutput << "// Output generated by CTCPPRenderer2D of CASETOOL\n";
   *myOutput << "//\n";
   // add comments to the bottom of the graphic
   //tm *myActualTime;
   //tm = localtime(time());
   time_t seconds;
   seconds = time(&seconds);
   tm* currentTime;
   currentTime = localtime(&seconds);
   *myOutput << "// Date: ";
   // the number for the month is 1 to small -> increment by one
   *myOutput << currentTime->tm_mday << "." << (currentTime->tm_mon + 1) << "." << currentTime->tm_year;
   *myOutput << ", Time: " << currentTime->tm_hour << ":";
   // correct leading 0 when minutes have only one and not the needed 2 digits
   if (currentTime->tm_min < 10) {
     *myOutput << "0";
     };
   *myOutput << currentTime->tm_min << ", User: " << getlogin() << "\n";
   *myOutput << "//\n";
      
}

CTCPPRenderer2D::CTCPPRenderer2D()
{
  myCurrentIdent = "";
  myIdent = "  ";
  myOutput = &std::cout;
}

Traversal::Result CTCPPRenderer2D::visit(CTClassDescription2D* obj)
{

   // do the rendering of the class:
   // ?? const TransMatrix2D& trans = myTraversal->getPath()->getLastTransform().getTransMatrix();

   *myOutput << "\n";
   if (obj->getIsTemplate()) {
     *myOutput << "template " << obj->getTemplateParameters() << "\n";
     };
   *myOutput << "class " << obj->getName();
   
   // Basisklassen ausgeben
   if (obj->getBaseclassIndexMax() >= obj->getBaseclassIndexMin()) {
     *myOutput << "\n";
     CTBaseclassDescription aBaseclass;
     for (int i=obj->getBaseclassIndexMin(); i <= obj->getBaseclassIndexMax(); i++) {
       if (i == obj->getBaseclassIndexMin()) {
         *myOutput << ": ";
         }
       else {
         *myOutput << ", ";
         };
       aBaseclass = obj->getBaseclassByIndex(i);
       
       if (aBaseclass.getView() == CTBaseclassDescription::Private) {
         *myOutput << "private ";
         }
       else {
         if (aBaseclass.getView() == CTBaseclassDescription::Protected) {
           *myOutput << "protected ";
           }
         else {
           *myOutput << "public ";
           };
         };
       
       *myOutput << aBaseclass.getBaseclass()->getName();
       };
     *myOutput << "\n";   
     };
     
   if ((obj->getAttributeIndexMax() < obj->getAttributeIndexMin()) &&
       (obj->getOperationIndexMax() < obj->getOperationIndexMin()) ) {
     // empty class
     *myOutput << ";\n";
     }
   else {
     // non-empty class
     if (obj->getBaseclassIndexMax() >= obj->getBaseclassIndexMin()) {
       *myOutput << myIdent << "{\n";
       }
     else {
       *myOutput << " " << "{\n";
       };
     bool firstTime;
     // print out all the operations
     if (obj->getOperationIndexMax() < obj->getOperationIndexMin()) {
       *myOutput << myIdent << "// no Operations\n";
       }
     else {
       *myOutput << myIdent << "// Operations\n";
       CTOperationDescription tmpOp;
       CTOperationDescription::CTEView tmpView;
       RCString tmpViewString; 
       for (int k=1; k <= 3; k++) {
         // print the members that are private, public or protected         
         switch (k) {
           case 1: tmpView = CTOperationDescription::Public;
                   tmpViewString = "public";
                   break;
           case 2: tmpView = CTOperationDescription::Protected;
                   tmpViewString = "protected";
                   break;
           case 3: tmpView = CTOperationDescription::Private;
                   tmpViewString = "private";
                   break;         
           };
         firstTime = true;
         for (int i=obj->getOperationIndexMin(); i <= obj->getOperationIndexMax(); i++) {
           tmpOp = obj->getOperationByIndex(i);
           if (tmpOp.getView() == tmpView ) {
             if (firstTime == true) {
               *myOutput << myIdent << tmpViewString << ":\n";
               firstTime = false;
               };
             *myOutput << myIdent << myIdent;
             if (tmpOp.getIsAbstract()) {
               *myOutput << "virtual ";
               };
             if (tmpOp.getReturnType() != "") {
               *myOutput << tmpOp.getReturnType() << " ";
               };
             *myOutput << tmpOp.getName() << "(";
             // write all the parameters
             for(int j=tmpOp.getParameterIndexMin(); j <= tmpOp.getParameterIndexMax(); j++) {
               *myOutput << tmpOp.getParameterByIndex(j).getType();
               if (tmpOp.getParameterByIndex(j).getName() != "") {
                 *myOutput << " " << tmpOp.getParameterByIndex(j).getName();
                 };
               if (tmpOp.getParameterByIndex(j).getInitValue() != "") {
                 *myOutput << " = " << tmpOp.getParameterByIndex(j).getInitValue();
                 };
               if ( (j < tmpOp.getParameterIndexMax()) && (tmpOp.getParameterIndexMax() > tmpOp.getParameterIndexMin()) ) {
                 *myOutput << ", ";
                 };            
               };
             *myOutput << ");\n";
             };
           };     
         };
       // if (firstTime == false) { *myOutput << "\n"; };
       };
     // print out all the members
     *myOutput << "\n";
     if (obj->getAttributeIndexMax() < obj->getAttributeIndexMin()) {
       *myOutput << myIdent << "// no Members\n";
       }
     else {
       *myOutput << myIdent << "// Members\n";
       CTAttributeDescription tmpMember; 
       CTAttributeDescription::CTEView tmpView;
       RCString tmpViewString; 
       for (int k=1; k <= 3; k++) {
         // print the members that are private, public or protected         
         switch (k) {
           case 1: tmpView = CTAttributeDescription::Public;
                   tmpViewString = "public";
                   break;
           case 2: tmpView = CTAttributeDescription::Protected;
                   tmpViewString = "protected";
                   break;
           case 3: tmpView = CTAttributeDescription::Private;
                   tmpViewString = "private";
                   break;         
           };
         firstTime = true;
           for (int i=obj->getAttributeIndexMin(); i <= obj->getAttributeIndexMax(); i++) {
             tmpMember = obj->getAttributeByIndex(i);
             if (tmpMember.getView() == tmpView ) {
               if (firstTime == true) {
                 *myOutput << myIdent << tmpViewString << ":\n";
                 firstTime = false;
                 };           
               *myOutput << myIdent << myIdent << tmpMember.getType() << " ";
               *myOutput << tmpMember.getName() << ";\n";
               };
             };        
         };
       };
              
     *myOutput << myIdent << "};\n\n";
     }; // else -> non-empty class
     
   return Traversal::CONTINUE;
}

Traversal::Result CTCPPRenderer2D::dispatch(Makeable* obj)
{
  tryConcrete(CTClassDescription2D, obj);
  
  //
  // Create decomposition for objects other than triangles.
  //
  return Traversal::UNKNOWN;
}
