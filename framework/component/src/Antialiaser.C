/*
 * $RCSfile: Antialiaser.C,v $
 *
 * Copyright (C) 1994-96, Christoph Streit <streit@iam.unibe.ch>
 *                        Stephan Amann <amann@iam.unibe.ch>
 *                        University of Berne, Switzerland
 *
 * All rights reserved.
 *
 * This software may be freely copied, modified, and redistributed
 * provided that this copyright notice is preserved on all copies.
 *
 * You may not distribute this software, in whole or in part, as part of
 * any commercial product without the express consent of the authors.
 *
 * There is no warranty or other guarantee of fitness of this software
 * for any purpose.  It is provided solely "as is".
 *
 * -----------------------------------------------------------------------------
 *  $Id: Antialiaser.C,v 1.10 1996/09/13 08:03:18 streit Exp $
 * -----------------------------------------------------------------------------
 */
 
#include "booga/base/AbstractPixmap.h"
#include "booga/object/Pixmap2D.h"
#include "booga/object/Aggregate3D.h"
#include "booga/object/Aggregate2D.h"
#include "booga/object/World2D.h"
#include "booga/object/Camera3D.h"
#include "booga/object/Viewing3D.h"
#include "booga/component/Collector2DFor.h"
#include "booga/component/Rasterizer.h"
#include "booga/component/Collector3DFor.h"
#include "booga/component/Renderer.h"
#include "booga/component/Antialiaser.h"

//__________________________________________________________________ Antialiaser

implementRTTI(Antialiaser, Operation3DTo2D);

Antialiaser::Antialiaser()
{
  myRenderer = NULL;  
  myResultPixmap = NULL;
}

AbstractPixmap* Antialiaser::performRendering()
{
  World2D* world2D = myRenderer->execute(getWorld());
  
  if (world2D == NULL) {
    Report::warning("[Antialiaser::performRendering] nothing generated by renderer");
    return NULL;
  }

  AbstractPixmap* pixmap = NULL;
  
  //
  // Normally the renderer creates a Pixmap2D 
  //
  Collector2DFor<Pixmap2D> pixiCollector;
  pixiCollector.execute(world2D);
  
  pixiCollector.first();
  if (!pixiCollector.isDone())
    pixmap = pixiCollector.getObject()->orphanPixmap();
 
  //
  // No pixmap found yet -> try to generate a pixmap with the rasterizer.
  //
  if (pixmap == NULL) {
    Rasterizer rasterizer;
    World2D* result = rasterizer.execute(world2D);
    
    pixiCollector.execute(result);
  
    pixiCollector.first();
    if (!pixiCollector.isDone())
      pixmap = pixiCollector.getObject()->orphanPixmap();
    
    delete result;
  }

  delete world2D;
  
  if (pixmap == NULL)
    Report::warning("[Antialiaser::performRendering] nothing generated by renderer");
  
  return pixmap;
}

bool Antialiaser::preprocessing()
{
  if (!Operation3DTo2D::preprocessing())
    return false;

  if (myRenderer == NULL) {
    Report::warning("[Antialiaser::preprocessing] no renderer provided");
    return false;
  }
    
  //
  // Find a camera in the world.
  //  
  if (myRenderer->getCamera() == NULL) {
    Collector3DFor<Camera3D> camCollector;
    camCollector.execute(getWorld());
  
    //
    // Look for first camera in world, that is switched on.
    //
    for (camCollector.first(); !camCollector.isDone(); camCollector.next())
      if (camCollector.getObject()->isOn()) {
        myRenderer->adoptCamera(camCollector.createTransformedObject());
        break;
      }

    if (myRenderer->getCamera() == NULL) {
      Report::warning("[Antialiaser::preprocessing] no camera found");
      return false;
    }
  }

  myResultPixmap = createPixmap(myRenderer->getCamera()->getViewing()->getResolutionX(), 
                                myRenderer->getCamera()->getViewing()->getResolutionY());

  return true;
}

bool Antialiaser::postprocessing()
{
  //
  // Add the pixmap to the result wolrd object.
  //
  getResult()->getObjects()->adoptObject(new Pixmap2D(myResultPixmap));
  getResult()->getObjects()->computeBounds();
  myResultPixmap = NULL;
  
  return Operation3DTo2D::postprocessing();
}

void Antialiaser::cleanupAfterFailure()
{
  delete myResultPixmap;
  myResultPixmap = NULL;
}
