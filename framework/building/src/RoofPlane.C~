/*
 * $RCSfile: RoofPlane.C,v $
 *
 * Copyright (C) 1996, Thierry Matthey <matthey@iam.unibe.ch>
 *                     University of Berne, Switzerland
 *
 * All rights reserved.
 *
 * This software may be freely copied, modified, and redistributed
 * provided that this copyright notice is preserved on all copies.
 *
 * You may not distribute this software, in whole or in part, as part of
 * any commercial product without the express consent of the authors.
 *
 * There is no warranty or other guarantee of fitness of this software
 * for any purpose.  It is provided solely "as is".
 *
 * -----------------------------------------------------------------------------
 *  $Id: RoofPlane.C,v 1.5 1997/02/22 09:16:24 matthey Exp $
 * -----------------------------------------------------------------------------
 */

#include "booga/base/BoundingBox.h"
#include "booga/base/Geometry3D.h"
#include "booga/base/Geometry2D.h"
#include "booga/base/mathutilities.h"
#include "booga/object/Grid3D.h"
//#include "booga/object/Line3D.h"
//#include "booga/object/Sphere3D.h"
#include "booga/object/Polygon3D.h"
#include "booga/building/RoofPlane.h"
#include "booga/building/Building.h"

// ____________________________________________________________________ RoofPlane

implementRTTI(RoofPlane, Roof);

RoofPlane::RoofPlane(Exemplar exemplar)
:Roof(exemplar)
{}

RoofPlane::RoofPlane()
{}

RoofPlane::RoofPlane(Real ledge, Real angle)
{
  setLedge(ledge);
  setAngle(angle);
}

RoofPlane::RoofPlane(const RoofPlane& roofplane) : Roof(roofplane)
{
  myAngle = roofplane.myAngle;
}      

Object3D* RoofPlane::copy() const
{
  return new RoofPlane(*this);
}

Makeable* RoofPlane::make(RCString& errMsg, const List<Value*>* parameters) const
{
  checkParameterNumber(2);

  getParameter(1, Real, ledge);  
  getParameter(2, Real, angle);  

  RoofPlane* newRoof = new RoofPlane(*this);

  newRoof->setLedge(ledge);
  newRoof->setAngle(dtor(angle));

  return newRoof;
}


Object3D* RoofPlane::doCreateSubject(Building* building) const
{
  BoundingBox box;
  Grid3D* roof = new Grid3D(15,15,15);
  List<Vector3D> temp, flat,poly;
  List<Vector2D> boundingbox(4), vertices;
  List<List<Vector3D> > polygons, planes, planesbig;
  Vector3D a,b,c,d,u,v,n;
  bool polygonlost = false;
  bool notflat = false;
  
  if (getLedge() > 0)
    temp = computeLedge(building->getPolygon(0));
  else
    temp = building->getPolygon(0);
    
  long i,j,k,m,count,index;
  Real l,konst,z;
  // z-coord of the roof
  Real h = building->getVertex(0,0).z() + building->getHeight();

  // boundingbox of the roof
  for(i=0;i<temp.count();i++)
    box.expand(temp.item(i));
  l = (box.getMin()- box.getMax()).length();

  boundingbox.append(Vector2D(box.getMin().x(),box.getMin().y()));
  boundingbox.append(Vector2D(box.getMax().x(),box.getMin().y()));
  boundingbox.append(Vector2D(box.getMax().x(),box.getMax().y()));
  boundingbox.append(Vector2D(box.getMin().x(),box.getMax().y()));

  // 
  temp = Geometry3D::computeLayerXYPlane(l*EPSILON,temp);
  for(i=0;i<temp.count();i++)
    vertices.append(Vector2D(temp.item(i).x(),temp.item(i).y()));
  
  // Compute the halfplanes and intersect them with the neighbour planes.
  for(i=0;i < building->countPolygon(); i++){
    temp = building->getPolygonTop(i);

    flat.removeAll();
    for(j=0;j < temp.count(); j++){
      flat.append(Vector3D(temp.item(j).x(),temp.item(j).y(),h));
      if (!equal(temp.item(j).z(),h))
        notflat = true;
    }
    poly = Geometry3D::removeCollinearPoints(flat);
    flat = computeLedge(poly);

    if (getLedge() > EPSILON){
      Polygon3D* ledge;
      if (i==0){
        ledge = new Polygon3D(Geometry3D::changeOrientation(flat));
        ledge->addHole(poly);
      }
      else {
        ledge = new Polygon3D(poly);
        ledge->addHole(flat);
      }
      roof->adoptObject(ledge);
    }
    
    temp = Geometry3D::computeLayerXYPlane(-1,flat);
    for(j=0;j < flat.count(); j++){
      // the polygon
      a = flat.item(j);
      b = flat.item((j+1)%flat.count());
      u = (b-a).normalized();
      Real l2 = (a-b).length()*.25;
      poly.removeAll();
      poly.append(a);
      poly.append(b);
      a -= u * l2;
      b += u * l2;
      n = Vector3D((b-a).y(),-(b-a).x(),0).normalized();
      n = Vector3D(n.x(),n.y(),tan(0.5*M_PI-getAngle()));
      konst = -n.x()*a.x()-n.y()*a.y()-n.z()*a.z(); 
 
      c = a + Vector3D(-u.y(),u.x(),0)*l*.5;
      d = b + Vector3D(-u.y(),u.x(),0)*l*.5;
      z = (-d.x()*n.x()-d.y()*n.y()-konst)/n.z();
      poly.append(Vector3D(d.x(),d.y(),z));
      z = (-c.x()*n.x()-c.y()*n.y()-konst)/n.z();
      poly.append(Vector3D(c.x(),c.y(),z));
      planesbig.append(poly);
      
      // the small polygon
      a = flat.item(j);
      b = flat.item((j+1)%flat.count());
      c = a + (temp.item(j) - a).normalized()*l;
      d = b + (temp.item((j+1)%temp.count()) -b).normalized()*l;
      n = Vector3D((b-a).y(),-(b-a).x(),0).normalized();
      n = Vector3D(n.x(),n.y(),tan(0.5*M_PI-getAngle()));
      konst = -n.x()*a.x()-n.y()*a.y()-n.z()*a.z(); 
      poly.removeAll();
      poly.append(a);
      poly.append(b);
      List<Vector2D> intersect = Geometry2D::intersectSegmentSegment(Vector2D(a.x(),a.y()),
                                                                     Vector2D(c.x(),c.y()),
                                                                     Vector2D(b.x(),b.y()),
                                                                     Vector2D(d.x(),d.y()));
      if (intersect.count() < 1){     
        // clip polygon with boundingbox 
        count = boundingbox.count();
        for(k = 0;k<count;k++){
          intersect = Geometry2D::intersectSegmentSegment(Vector2D(b.x(),b.y()),
                                                            Vector2D(d.x(),d.y()),
                                                            boundingbox.item(k),
                                                            boundingbox.item((k+1)%count));
          if (intersect.count() > 0){
            if (!intersect.item(0).equal(Vector2D(b.x(),b.y()))){
              z = (-intersect.item(0).x()*n.x()-intersect.item(0).y()*n.y()-konst)/n.z();
              poly.append(Vector3D(intersect.item(0).x(),intersect.item(0).y(),z));
              break;
            }
          }
        }
                     
        for(m = k;m<count+k;m++){
          intersect = Geometry2D::intersectSegmentSegment(Vector2D(a.x(),a.y()),
                                                            Vector2D(c.x(),c.y()),
                                                            boundingbox.item(m%count),
                                                            boundingbox.item((m+1)%count));
          if (intersect.count() > 0){
            if (!intersect.item(0).equal(Vector2D(a.x(),a.y()))){
              z = (-intersect.item(0).x()*n.x()
                   -intersect.item(0).y()*n.y()-konst)/n.z();
              poly.append(Vector3D(intersect.item(0).x(),intersect.item(0).y(),z));
              break;
            }
          }
          else{
            z = (-boundingbox.item((m+1)%count).x()*n.x()
                 -boundingbox.item((m+1)%count).y()*n.y()-konst)/n.z();
            poly.append(Vector3D(boundingbox.item((m+1)%count).x(),boundingbox.item((m+1)%count).y(),z));
            
          }
        }
      }
      else{
        // polygon is a triangle
        z = (-intersect.item(0).x()*n.x()-intersect.item(0).y()*n.y()-konst)/n.z();
        poly.append(Vector3D(intersect.item(0).x(),intersect.item(0).y(),z));
      }
      poly = Geometry3D::removeCollinearPoints(poly);
      planes.append(poly);
    }
  }
  
  Geometry3D::Segment3D *segment, *segmentbig;  
  List<Geometry3D::Segment3D*> segmentlist;
 
  for(i=0;i<planes.count();i++){
    // intersectionlines of neighbour planes
    segmentlist.append(new Geometry3D::Segment3D(planes.item(i).item(1),planes.item(i).item(2)));
    segmentlist.append(new Geometry3D::Segment3D(planes.item(i).item(0),planes.item(i).item(planes.item(i).count()-1)));

    for(j=0;j<planes.count();j++){
      // no intersection between neighbours
      if (j != i && !planes.item(j).item(0).equal(planes.item(i).item(1))
                 && !planes.item(j).item(1).equal(planes.item(i).item(0))){
        a = Geometry3D::normal(planes.item(i));
        b = Geometry3D::normal(planes.item(j));
        // no intersection with collinear planes
        if(!a.equal(b) && !a.equal(-b)) {
          
          segment = Geometry3D::intersectCPolygonCPolygon(planes.item(i),planes.item(j)); 
          segmentbig = Geometry3D::intersectCPolygonCPolygon(planes.item(i),planesbig.item(j)); 

          if (segment == NULL){
            segment = segmentbig;
            segmentbig = NULL;
          }
          else if(segmentbig != NULL){
            a = segment->myStart;
            b = segment->myEnd;
            c = segmentbig->myStart;
            d = segmentbig->myEnd;
            if ((a-b).length() < (c-d).length() &&
                (min(c.z(),d.z()) <= EPSILON + min(a.z(),b.z()))){
              segment->myStart = c;
              segment->myEnd = d;
            }
            delete segmentbig; 
          }
          
          if (segment){
            a = segment->myStart;
            b = segment->myEnd;
            if (!a.equal(b))
              segmentlist.append(segment);
            else
              delete segment;
          }
        }
      }
    }
//    if(i==11){
//      for(j=0;j<segmentlist.count();j++){
//        roof->adoptObject(new Sphere3D(1,segmentlist.item(j)->myStart));
//        roof->adoptObject(new Sphere3D(1,segmentlist.item(j)->myEnd));
//      }
//    }
    
    // intersect the intersectionlines 
 
    List<Vector3D> intersectpoints;
    
    for(j=0; j<segmentlist.count(); j++){
      for(k=j+1; k<segmentlist.count();k++){
        a = segmentlist.item(j)->myStart;
        b = segmentlist.item(j)->myEnd;
        c = segmentlist.item(k)->myStart;
        d = segmentlist.item(k)->myEnd;
        if (!a.equal(c) && !a.equal(d) &&!b.equal(c) &&!b.equal(d)){
          temp = Geometry3D::intersectSegmentSegment(a,b,c,d);
          for(m=0; m<temp.count();m++){
            intersectpoints.append(temp.item(m)); 
          }
          // intersection not always commutative
          temp = Geometry3D::intersectSegmentSegment(c,d,a,b);
          for(m=0; m<temp.count();m++){
            intersectpoints.append(temp.item(m)); 
          }
        }
      }
    }
 
    for(j=0;j<intersectpoints.count();j++){
      c = intersectpoints.item(j);
      for(k=0;k<segmentlist.count();k++){
        a = segmentlist.item(k)->myStart;
        b = segmentlist.item(k)->myEnd;
        if ((a-c).length() > EPSILON && (b-c).length() > EPSILON && ((a-c).normalized()).equal((c-b).normalized())){ 
          segmentlist.item(k)->myEnd = c;
          segmentlist.insert(k,new Geometry3D::Segment3D(b,c));                   
          k = -1;
        }
      }
    }   
  
    poly.removeAll();
    poly.append(planes.item(i).item(0));      
    poly.append(planes.item(i).item(1));      
    Real alpha;
    Real alphalast;
//    if(i == 31){
//      for(j=0;j<segmentlist.count();j++){
//        a = segmentlist.item(j)->myStart;
//        b = segmentlist.item(j)->myEnd;
//        roof->adoptObject(new Sphere3D(0.5,a + (b-a).normalized() ));
//        roof->adoptObject(new Sphere3D(0.5,b - (b-a).normalized()));
//      }
//    }
        
    // compute the intersectionpath which is most left        
    while (!planes.item(i).item(0).equal(poly.item(poly.count()-1))){
      index = -1;
      v = poly.item(poly.count()-1);
      a = (poly.item(poly.count()-2)-v).normalized();
      for(j=0;j<segmentlist.count();j++){
        if (v.equal(segmentlist.item(j)->myEnd)){
          c = segmentlist.item(j)->myEnd;        
          d = segmentlist.item(j)->myStart;        
        }  
        else {
          c = segmentlist.item(j)->myStart;        
          d = segmentlist.item(j)->myEnd;
        }
                
        if (v.equal(c)){
          b = (d - v).normalized();
          n = b * a;
          alpha = asin(n.z() > 0 ? n.length() : - n.length());
          alpha = (a-b).length() > sqrt(2) ? M_PI - alpha : 2*M_PI + alpha;
          alpha = alpha >= 2*M_PI ? alpha - 2*M_PI : alpha;
          if (index < 0 || alpha < alphalast){
            u = d;
            index = j;
            alphalast = alpha;
          }
        }
      }
          
      if (index >= 0){
        poly.append(u);
        delete segmentlist.item(index);
        segmentlist.remove(index);  
      }
      else{
        // backtrack
        if (poly.count()>2)            
          poly.remove(poly.count()-1); 
        else{
          break;
        }
      }
    }
    
    poly = Geometry3D::removeCollinearPoints(poly);        

    // add the polygon to the roof
    if (Geometry3D::area(poly) > EPSILON){
      List<Vector2D> temp2;
      for(j=0;j<poly.count();j++)
        temp2.append(Vector2D(poly.item(j).x(),poly.item(j).y())); 
      if(Geometry2D::INSIDE == Geometry2D::polygonInPolygon(temp2,vertices)){
//        for(k=0;k < poly.count();k++)
//          roof->adoptObject(new Line3D(poly.item(k),poly.item((k+1)%poly.count())));
        roof->adoptObject(new Polygon3D(poly));
      }
      else
        polygonlost = true;      
    }
    else
      polygonlost = true;
 
    for(j=0;j<segmentlist.count();j++)
      delete segmentlist.item(j);

    segmentlist.removeAll();  
  }
  if(polygonlost){
    Report::hint("[RoofPlane::doCreateSubject] polygons not found");  
  }
  if(notflat){
    Report::hint("[RoofPlane::doCreateSubject] fronts with peaks");  
  }
  return roof;
}

List<Value*>* RoofPlane::createParameters() {
  List<Value*>* parameters = new List<Value*>;
  parameters->append(new Value(getLedge()));
  parameters->append(new Value(rtod(getAngle())));
  return parameters;
}

static const RCString roofplaneKeyword("roofplane");

RCString RoofPlane::getKeyword() const {
  return roofplaneKeyword;
}

void RoofPlane::setAngle(Real angle)
{
  if (angle < dtor(5)){
    ostrstream os;
    os << "[RoofPlane::setAngle] angle less then 5 deg. ";
    Report::warning(os);
    myAngle = dtor(5);
  }
  else if (angle > dtor(85)){
    ostrstream os;
    os << "[RoofPlane::setAngle] angle greater then 85 deg. ";
    Report::warning(os);
    myAngle = dtor(85);
  }
  else 
    myAngle = angle;
}

