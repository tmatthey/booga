/*
 * GLUtilities.C
 *
 * Copyright (C) 1994-96, Christoph Streit <streit@iam.unibe.ch>
 *                        Stephan Amann <amann@iam.unibe.ch>
 *                        University of Berne, Switzerland
 *
 * All rights reserved.
 *
 * This software may be freely copied, modified, and redistributed
 * provided that this copyright notice is preserved on all copies.
 *
 * You may not distribute this software, in whole or in part, as part of
 * any commercial product without the express consent of the authors.
 *
 * There is no warranty or other guarantee of fitness of this software
 * for any purpose.  It is provided solely "as is".
 *
 * -----------------------------------------------------------------------------
 *  $Id: GLUtilities.C,v 1.15 1998/02/04 13:13:20 buhlmann Exp $
 * -----------------------------------------------------------------------------
 */
 
#ifdef HAVE_OPENGL
# include <GL/gl.h>
# include <GL/glu.h>
#endif

#include "booga/base/mathutilities.h"
#include "booga/base/Configuration.h"
#include "booga/base/PixmapOption.h" 
#include "booga/base/PixmapOf.h"
#include "booga/base/AbstractPixmap.h"
#include "booga/base/Report.h"

#include "booga/object/PerspectiveViewing3D.h"
#include "booga/object/OrthographicViewing3D.h"

#include "booga/glwrapper/GlutBridge.h"
#include "booga/glwrapper/GLUtilities.h"

//__________________________________________________________________ GLUtilities

implementInitStatics(GLUtilities);

GLAbstractBridge* GLUtilities::ourToolkitBridge;

void GLUtilities::initClass()
{
  if (ourToolkitBridge == NULL)
    ourToolkitBridge = new GlutBridge();
}

void GLUtilities::adoptBridge(GLAbstractBridge* bridge)
{
  if (bridge != NULL) {
    delete ourToolkitBridge;
    ourToolkitBridge = bridge;
  }
  else
    Report::recoverable("[GLUtilities::adoptBridge] NULL pointer passed");
}

AbstractPixmap* GLUtilities::createPixmapFromFramebuffer(AbstractPixmap* proto)
{
  AbstractPixmap* result;

  //
  // Get default pixmap type from configuration database if no prototype
  // is provided.
  //
  if (proto == NULL) {
    getConfigurationOption(PixmapOption, pixiOption, "Pixmap.Type");
    if (pixiOption != NULL)
      result = pixiOption->getPixmap()->copy();
    else
      result = new PixmapOf<RGB>(1,1);
  }
  else    
    result = proto->copy();
  
  //
  // Generated pixmap has the size of the viewport.
  //
#ifdef HAVE_OPENGL
  GLint viewport[4]; // -> x, y, width, height
  glGetIntegerv(GL_VIEWPORT, viewport);
  GLint width  = viewport[2]-viewport[0];
  GLint height = viewport[3]-viewport[1];
  result->setResolution(width, height);

  long size = width*height*3;
  GLfloat* pixels = new GLfloat[size];
  GLint drawBuffer;
  glGetIntegerv(GL_DRAW_BUFFER, &drawBuffer);
  glReadBuffer((GLenum)drawBuffer);  // read from correct buffer
  
  glReadPixels(viewport[0], viewport[1], width, height, GL_RGB, GL_FLOAT, pixels);
  
  for (long i=0, pos=0; i<size; i+=3, pos++) {
    result->setPosition(pos);
    result->setColor(pixels[i], pixels[i+1], pixels[i+2]);
  }
  

  delete [] pixels;
#endif // HAVE_OPENGL
  
  return result;
}

bool GLUtilities::isEventPending()
{
  return ourToolkitBridge->isEventPending();
}

void GLUtilities::swapBuffers()
{
  ourToolkitBridge->swapBuffers();
}

void GLUtilities::setupViewingMatrix(Viewing3D* viewing)
{
#ifdef HAVE_OPENGL
  int width  = viewing->getResolutionX();
  int height = viewing->getResolutionY();
  Real vFov  = viewing->getVFov();
  Vector3D eye    = viewing->getEye();
  Vector3D lookat = viewing->getLookat();
  Vector3D up     = viewing->getUp();

  glViewport(0, 0, (GLint)width, (GLint)height);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  gluLookAt((GLdouble)eye.x(),    (GLdouble)eye.y(),    (GLdouble)eye.z(),
            (GLdouble)lookat.x(), (GLdouble)lookat.y(), (GLdouble)lookat.z(), 
            (GLdouble)up.x(),     (GLdouble)up.y(),     (GLdouble)up.z()); 

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  const GLdouble zNear = 0.1;
  const GLdouble zFar  = MAXFLOAT; // Has to be MAXFLOAT!

  if (dynamic_cast(PerspectiveViewing3D, viewing)) {
    gluPerspective(rtod(vFov), (GLdouble) width/height, zNear, zFar);
  }
  else if (dynamic_cast(OrthographicViewing3D, viewing)){
    GLdouble horiz = viewing->getScreenDeltaU().length() * width  / 2;
    GLdouble vert  = viewing->getScreenDeltaV().length() * height / 2;
    glOrtho(-horiz, horiz, -vert, vert, zNear, zFar);
  }
  else {
    Report::warning("[GLUtilities::setupViewingMatrix] unknown viewing type, using perspective");
    gluPerspective(rtod(vFov), (GLdouble) width/height, zNear, zFar);
  }
  
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  gluLookAt((GLdouble)eye.x(),    (GLdouble)eye.y(),    (GLdouble)eye.z(),
            (GLdouble)lookat.x(), (GLdouble)lookat.y(), (GLdouble)lookat.z(), 
            (GLdouble)up.x(),     (GLdouble)up.y(),     (GLdouble)up.z()); 
#endif // HAVE_OPENGL
}

void GLUtilities::drawCube(RenderingType type)
{
#ifdef HAVE_OPENGL
  static GLdouble n[6][3] =
  {
    {-1.0,  0.0,  0.0},
    { 0.0,  1.0,  0.0},
    { 1.0,  0.0,  0.0},
    { 0.0, -1.0,  0.0},
    { 0.0,  0.0,  1.0},
    { 0.0,  0.0, -1.0}
  };
  
  static GLint faces[6][4] =
  {
    {0, 1, 2, 3},
    {3, 2, 6, 7},
    {7, 6, 5, 4},
    {4, 5, 1, 0},
    {5, 6, 2, 1},
    {7, 4, 0, 3}
  };
  
  GLdouble v[8][3];

  v[0][0] = v[1][0] = v[2][0] = v[3][0] = -.5;
  v[4][0] = v[5][0] = v[6][0] = v[7][0] =  .5;
  v[0][1] = v[1][1] = v[4][1] = v[5][1] = -.5;
  v[2][1] = v[3][1] = v[6][1] = v[7][1] =  .5;
  v[0][2] = v[3][2] = v[4][2] = v[7][2] = -.5;
  v[1][2] = v[2][2] = v[5][2] = v[6][2] =  .5;

  for (int i = 0; i < 6; i++) {
    if (type == WIRE) 
      glBegin(GL_LINE_LOOP);
    else
      glBegin(GL_QUADS);
    
     glNormal3dv(&n[i][0]);
     glTexCoord2f(-.5,-.5);
     glVertex3dv(&v[faces[i][0]][0]);
     glTexCoord2f(-.5,.5);
     glNormal3dv(&n[i][0]);
     glVertex3dv(&v[faces[i][1]][0]);
     glTexCoord2f(.5,.5);
     glNormal3dv(&n[i][0]);
     glVertex3dv(&v[faces[i][2]][0]);
     glTexCoord2f(.5,-.5);
     glNormal3dv(&n[i][0]);
     glVertex3dv(&v[faces[i][3]][0]);
    glEnd();
  }
#endif // HAVE_OPENGL
}

void GLUtilities::drawSphere(Real radius, int slices, int stacks, 
                             RenderingType type)
{
#ifdef HAVE_OPENGL
  static GLUquadricObj* theSphereQuad = gluNewQuadric();
  
  if (type == WIRE) {
    gluQuadricDrawStyle(theSphereQuad, (GLenum)GLU_LINE);
    gluQuadricTexture(theSphereQuad, GL_FALSE);
  } else {
    gluQuadricDrawStyle(theSphereQuad, (GLenum)GLU_FILL);
    gluQuadricNormals(theSphereQuad, (GLenum)GLU_SMOOTH);
    gluQuadricTexture(theSphereQuad, GL_TRUE);
  }

  gluSphere(theSphereQuad, radius, slices, stacks);
#endif // HAVE_OPENGL
}

void GLUtilities::drawCone(Real radiusStart, Real radiusEnd, Real height, 
                           bool isClosed, 
                           int slices, int stacks, RenderingType type)
{
#ifdef HAVE_OPENGL
  Real r1 = radiusStart;
  Real r2 = radiusEnd;

  if (equal(r1,0) && r1 < 0){
    r1 = 0.0;
  }
  else if (r1 < 0){
    ostrstream os;
    os << "[GLUtilities::drawCone] radiusStart is " << radiusStart;
    Report::warning(os); 
    return;
  }

  if (equal(r2,0) && r2 < 0){
    r2 = 0.0;
  }
  else if (r2 < 0){
    ostrstream os;
    os << "[GLUtilities::drawCone] radiusEnd is " << radiusEnd;
    Report::warning(os); 
    return;
  }

  static GLUquadricObj* theConeQuad = gluNewQuadric();
  static GLUquadricObj* theDiscQuad = gluNewQuadric();

  if (type == WIRE) {
    gluQuadricDrawStyle(theConeQuad, (GLenum)GLU_LINE);
    gluQuadricDrawStyle(theDiscQuad, (GLenum)GLU_LINE);
    gluQuadricTexture(theConeQuad, GL_FALSE);
    gluQuadricTexture(theDiscQuad, GL_FALSE);
  } 
  else {
    gluQuadricTexture(theConeQuad, GL_TRUE);
    gluQuadricDrawStyle(theConeQuad, (GLenum)GLU_FILL);
    gluQuadricNormals(theConeQuad, (GLenum)GLU_SMOOTH);
    gluQuadricDrawStyle(theDiscQuad, (GLenum)GLU_FILL);
    gluQuadricTexture(theDiscQuad, GL_TRUE);
  }

  gluCylinder(theConeQuad, r1, r2, height, slices, stacks);
 
  if (isClosed) {
    if (!equal(r1, 0)) {
      gluQuadricOrientation(theDiscQuad, (GLenum)GLU_INSIDE);
      gluDisk(theDiscQuad, 0, r1, slices, 1);
    }

    if (!equal(r2, 0)) {  
      glPushMatrix();
        glTranslatef(0,0,height);
        gluQuadricOrientation(theDiscQuad, (GLenum)GLU_OUTSIDE);
        gluDisk(theDiscQuad, 0, r2, slices, 1);
      glPopMatrix();
    }
  }    
#endif // HAVE_OPENGL
}

void GLUtilities::drawTorus(Real sweptRadius, Real tubeRadius, 
                            int nsides, int rings, 
                            RenderingType type)
{
#ifdef HAVE_OPENGL
  GLdouble theta, phi, theta1, phi1;
  GLdouble p0[03], p1[3], p2[3], p3[3];
  GLdouble n0[3], n1[3], n2[3], n3[3];

  for (register int i = 0; i < rings; i++) {
    theta = (GLdouble) i *2.0 * M_PI / rings;
    theta1 = (GLdouble) (i + 1) * 2.0 * M_PI / rings;
    for (register int j = 0; j < nsides; j++) {
      phi = (GLdouble) j *2.0 * M_PI / nsides;
      phi1 = (GLdouble) (j + 1) * 2.0 * M_PI / nsides;

      p0[0] =  cos(theta) * (tubeRadius + sweptRadius * cos(phi));
      p0[1] = -sin(theta) * (tubeRadius + sweptRadius * cos(phi));
      p0[2] = sweptRadius * sin(phi);

      p1[0] =  cos(theta1) * (tubeRadius + sweptRadius * cos(phi));
      p1[1] = -sin(theta1) * (tubeRadius + sweptRadius * cos(phi));
      p1[2] = sweptRadius * sin(phi);

      p2[0] =  cos(theta1) * (tubeRadius + sweptRadius * cos(phi1));
      p2[1] = -sin(theta1) * (tubeRadius + sweptRadius * cos(phi1));
      p2[2] = sweptRadius * sin(phi1);

      p3[0] =  cos(theta) * (tubeRadius + sweptRadius * cos(phi1));
      p3[1] = -sin(theta) * (tubeRadius + sweptRadius * cos(phi1));
      p3[2] = sweptRadius * sin(phi1);

      n0[0] =  cos(theta) * (cos(phi));
      n0[1] = -sin(theta) * (cos(phi));
      n0[2] = sin(phi);

      n1[0] =  cos(theta1) * (cos(phi));
      n1[1] = -sin(theta1) * (cos(phi));
      n1[2] = sin(phi);

      n2[0] =  cos(theta1) * (cos(phi1));
      n2[1] = -sin(theta1) * (cos(phi1));
      n2[2] = sin(phi1);

      n3[0] =  cos(theta) * (cos(phi1));
      n3[1] = -sin(theta) * (cos(phi1));
      n3[2] = sin(phi1);

      if (type == WIRE) 
        glBegin(GL_LINE_LOOP);
      else
        glBegin(GL_QUADS);

        glNormal3dv(n3);
        glVertex3dv(p3);
        glNormal3dv(n2);
        glVertex3dv(p2);
        glNormal3dv(n1);
        glVertex3dv(p1);
        glNormal3dv(n0);
        glVertex3dv(p0);
      glEnd();
    }
  }
#endif // HAVE_OPENGL
}

#ifdef HAVE_OPENGL
static GLubyte rasters[][13] = {
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36}, 
{0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x66, 0x00, 0x00}, 
{0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18}, 
{0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70}, 
{0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e}, 
{0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c}, 
{0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30}, 
{0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00}, 
{0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00}, 
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03}, 
{0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c}, 
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e}, 
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e}, 
{0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c}, 
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e}, 
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e}, 
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06}, 
{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60}, 
{0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e}, 
{0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18}, 
{0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff}, 
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e}, 
{0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06}, 
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3}, 
{0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e}, 
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe}, 
{0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c}, 
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe}, 
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3}, 
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff}, 
{0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c}, 
{0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60}, 
{0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18}, 
{0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70}, 
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0}, 
{0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03, 0x03}, 
{0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e}, 
{0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0}, 
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00}, 
{0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00}, 
{0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0}, 
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78}, 
{0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00}, 
{0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00}, 
{0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00}, 
{0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00}, 
{0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f}, 
{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18}, 
{0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00} 
};

static GLuint fontOffset;
#endif // HAVE_OPENGL

static void makeRasterFont()
{
#ifdef HAVE_OPENGL
  GLuint i;
  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

  fontOffset = glGenLists(128);
  for (i = 32; i < 127; i++) {
    glNewList(i+fontOffset, GL_COMPILE);
    glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, rasters[i-32]);
    glEndList();
  }
#endif // HAVE_OPENGL
}

void GLUtilities::drawText(const RCString& text)
{
  static bool initialized = false;
  
  if (!initialized) {
    makeRasterFont();
    initialized = true;
  }
  
#ifdef HAVE_OPENGL
  const char* s = text.chars();
  glPushAttrib (GL_LIST_BIT);
    glListBase(fontOffset);
    glCallLists(strlen(s), GL_UNSIGNED_BYTE, (GLubyte *) s);
  glPopAttrib ();
#endif // HAVE_OPENGL
}
