/*
 * $RCSfile: Box3D.C,v $
 *
 * Copyright (C) 1994-96, Christoph Streit <streit@iam.unibe.ch>
 *                        Stephan Amann <amann@iam.unibe.ch>
 *                        University of Berne, Switzerland
 *
 * All rights reserved.
 *
 * This software may be freely copied, modified, and redistributed
 * provided that this copyright notice is preserved on all copies.
 *
 * You may not distribute this software, in whole or in part, as part of
 * any commercial product without the express consent of the authors.
 *
 * There is no warranty or other guarantee of fitness of this software
 * for any purpose.  It is provided solely "as is".
 *
 * -----------------------------------------------------------------------------
 *  $Id: Box3D.C,v 1.22 1996/10/04 09:45:48 collison Exp $
 * -----------------------------------------------------------------------------
 */

#include <strstream.h>
#include "booga/base/Value.h"
#include "booga/object/BoundsUtilities.h"  // slapTest
#include "booga/object/List3D.h"
#include "booga/object/Box3D.h"
#include "booga/object/Triangle3D.h"

// ____________________________________________________________________ Box3D

implementRTTI(Box3D, Primitive3D);

Box3D::Box3D(Exemplar exemplar)
: Primitive3D(exemplar)
{
  myFrom = Vector3D(0,0,0);
  myTo   = Vector3D(1,1,1);
}

Box3D::Box3D(const Vector3D& from, const Vector3D& to)
: myFrom(from), myTo(to)
{}

Object3D* Box3D::createDecomposition() const
{
  List3D* triangles = new List3D;

  Vector3D corner[8];
  Vector3D normals[6];
  int planes[6][4];
  register int i;

  // Get correct position in space.
  Vector3D minCorner(myFrom.x()<myTo.x() ? myFrom.x() : myTo.x(),
		   myFrom.y()<myTo.y() ? myFrom.y() : myTo.y(),
		   myFrom.z()<myTo.z() ? myFrom.z() : myTo.z());
  Vector3D maxCorner(myFrom.x()>myTo.x() ? myFrom.x() : myTo.x(),
		   myFrom.y()>myTo.y() ? myFrom.y() : myTo.y(),
		   myFrom.z()>myTo.z() ? myFrom.z() : myTo.z());

  // 8 vertices of the box
  corner[0] = Vector3D(minCorner.x(), minCorner.y(), minCorner.z());
  corner[1] = Vector3D(minCorner.x(), minCorner.y(), maxCorner.z());
  corner[2] = Vector3D(minCorner.x(), maxCorner.y(), minCorner.z());
  corner[3] = Vector3D(minCorner.x(), maxCorner.y(), maxCorner.z());
  corner[4] = Vector3D(maxCorner.x(), minCorner.y(), minCorner.z());
  corner[5] = Vector3D(maxCorner.x(), minCorner.y(), maxCorner.z());
  corner[6] = Vector3D(maxCorner.x(), maxCorner.y(), minCorner.z());
  corner[7] = Vector3D(maxCorner.x(), maxCorner.y(), maxCorner.z());

  // 6 normals of the box on each plane
  normals[0] = Vector3D(0,0,-1);
  normals[1] = Vector3D(1,0,0);
  normals[2] = Vector3D(0,1,0);
  normals[3] = Vector3D(0,-1,0);
  normals[4] = Vector3D(-1,0,0);
  normals[5] = Vector3D(0,0,1);

  // 6 planes of the box with vertices in counter clockwise order
  planes[0][0] = 0; planes[0][1] = 2; planes[0][2] = 6; planes[0][3] = 4;
  planes[1][0] = 4; planes[1][1] = 6; planes[1][2] = 7; planes[1][3] = 5;
  planes[2][0] = 2; planes[2][1] = 3; planes[2][2] = 7; planes[2][3] = 6;
  planes[3][0] = 0; planes[3][1] = 4; planes[3][2] = 5; planes[3][3] = 1;
  planes[4][0] = 0; planes[4][1] = 1; planes[4][2] = 3; planes[4][3] = 2;
  planes[5][0] = 1; planes[5][1] = 5; planes[5][2] = 7; planes[5][3] = 3;
  

  for (i=0; i<6; i++) {
    triangles->adoptObject(new Triangle3D(corner[planes[i][0]], normals[i], 
                                          corner[planes[i][1]], normals[i],
                                          corner[planes[i][2]], normals[i]));
    triangles->adoptObject(new Triangle3D(corner[planes[i][0]], normals[i], 
			               corner[planes[i][2]], normals[i],
			               corner[planes[i][3]], normals[i]));
  }
 
  triangles->computeBounds();
  return triangles;
}

Vector3D Box3D::normal(const Vector3D& point) const
{
  Vector3D retval(0,0,0);

  Real minDist = MAXREAL;
  Real dist;
  
  dist = fabs(point.x() - myFrom.x());
  if (dist < minDist) {
    minDist = dist;
    retval = Vector3D(myFrom.x()<myTo.x() ? -1 : 1, 0, 0);
  }
  
  dist = fabs(point.x() - myTo.x());
  if (dist < minDist) {
    minDist = dist;
    retval = Vector3D(myTo.x()>myFrom.x() ? 1 : -1, 0, 0);
  }

  dist = fabs(point.y() - myFrom.y());
  if (dist < minDist) {
    minDist = dist;
    retval = Vector3D(0, myFrom.y()<myTo.y() ? -1 : 1, 0);
  }

  dist = fabs(point.y() - myTo.y());
  if (dist < minDist) {
   minDist = dist;
   retval = Vector3D(0, myTo.y()>myFrom.y() ? 1 : -1, 0);
  }

  dist = fabs(point.z() - myFrom.z());
  if (dist < minDist) {
    minDist = dist;
    retval = Vector3D(0, 0, myFrom.z()<myTo.z() ? -1 : 1);
  }
  
  dist = fabs(point.z() - myTo.z());
  if (dist < minDist) {
    minDist = dist;
    retval = Vector3D(0, 0, myTo.z()>myFrom.z() ? 1 : -1);
  }

  if (minDist >= MAXREAL) {
    ostrstream os;
    os << "[Box3D::normal] point (" << point << ") not on surface. "
       << "Box has dimensions (" << myFrom << ", " << myTo << ")";
    Report::recoverable(os);
    //
    // Compute default normal,  must have a length != 0
    //
    retval = (point-(myFrom+myTo)/2).normalized();
  }
  
  return retval;
}

Object3D* Box3D::copy() const
{
  return new Box3D(*this);
}

bool Box3D::doIntersect(Ray3D& ray)
{
  // Get correct position in space.
  Vector3D minCorner(myFrom.x()<myTo.x() ? myFrom.x() : myTo.x(),
		   myFrom.y()<myTo.y() ? myFrom.y() : myTo.y(),
		   myFrom.z()<myTo.z() ? myFrom.z() : myTo.z());
  Vector3D maxCorner(myFrom.x()>myTo.x() ? myFrom.x() : myTo.x(),
		   myFrom.y()>myTo.y() ? myFrom.y() : myTo.y(),
		   myFrom.z()>myTo.z() ? myFrom.z() : myTo.z());

  Real tmax = ray.getBestHitDistance();
  Real tmin = ray.getTolerance();
 
  for (int i=0; i<3; i++)
    if (!BoundsUtilities::slabTest(ray.getDirection()[i], ray.getOrigin()[i], 
                                   minCorner[i], maxCorner[i],
                                   tmin, tmax))
      return false;
 
  if (tmin < ray.getBestHitDistance() && tmin > ray.getTolerance()) {
    ray.setBestHitObject(this);
    ray.setBestHitDistance(tmin);
    return true;
  }

  // Shouldn't we have this case also? !!!!!!!!!
  // -----
  //  else if (tmax < ray.getBestHitDistance() && tmax > ray.getTolerance()) {
  //    ray.setBestHitObject(this);
  //    ray.setBestHitDistance(tmax);
  //    return true;
  //  }
     
  return false;
}

void Box3D::doComputeBounds()
{
  myBounds.expand(myFrom);
  myBounds.expand(myTo);
}
  
Makeable* Box3D::make(RCString& errMsg, const List<Value*>* parameters) const
{
  checkParameterNumber(2);
  getParameter(1, Vector3D, from);
  getParameter(2, Vector3D, to);

  Box3D* newBox = new Box3D(*this);

  newBox->setFrom(from);
  newBox->setTo(to);

  return newBox;
}

static const RCString boxKeyword("box");

RCString Box3D::getKeyword() const {
  return boxKeyword;
}

List<Value*>* Box3D::createParameters() {
  List<Value*>* parameters = new List<Value*>;
  parameters->append(new Value(getFrom()));
  parameters->append(new Value(getTo()));
  return parameters;
}
