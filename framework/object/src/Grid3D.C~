/*
 * $RCSfile: Grid3D.C,v $
 *
 * Copyright (C) 1994-96, Stephan Amann <amann@iam.unibe.ch>
 *                        Christoph Streit <streit@iam.unibe.ch>
 *                        University of Berne, Switzerland
 *
 * All rights reserved.
 *
 * This software may be freely copied, modified, and redistributed
 * provided that this copyright notice is preserved on all copies.
 *
 * You may not distribute this software, in whole or in part, as part of
 * any commercial product without the express consent of the authors.
 *
 * There is no warranty or other guarantee of fitness of this software
 * for any purpose.  It is provided solely "as is".
 *
 * -----------------------------------------------------------------------------
 *  $Id: Grid3D.C,v 1.11 1996/10/04 09:46:38 collison Exp $
 * -----------------------------------------------------------------------------
 */

#include <strstream.h>
#include <math.h>

#include "booga/base/Value.h"
#include "booga/base/Report.h"
#include "booga/object/Grid3D.h"

static unsigned long intersectCallCounter = 0;

inline int boundsFloor(Real value, int lower, int upper)
{
  int retval = (int)floor(value);
  if (retval < lower)
    retval = lower;
  else if (retval > upper)
    retval = upper;
    
  return retval;
}

//_______________________________________________________________________ Grid3D

implementRTTI(Grid3D, Aggregate3D);

Grid3D::Grid3D(int sizeX, int sizeY, int sizeZ)
{
  myDimension[0] = sizeX;
  myDimension[1] = sizeY;
  myDimension[2] = sizeZ;
  
  myCells = NULL;
  myAreCellsValid = false;
}

Grid3D::Grid3D(Exemplar exemplar) 
: Aggregate3D(exemplar)
{
  myCells = NULL;
  myAreCellsValid = false;
  myDimension[0] = myDimension[1] = myDimension[2] = 1;
}

Grid3D::Grid3D(const Grid3D& grid)
: Aggregate3D(grid)
{
  myDimension[0] = grid.myDimension[0];
  myDimension[1] = grid.myDimension[1];
  myDimension[2] = grid.myDimension[2];

  myCells = NULL;
  myAreCellsValid = false;                                
}

Grid3D::~Grid3D()
{
  if (myCells != NULL){
    for (long i = 0; i < myDimension[0]*myDimension[1]*myDimension[2]; i++)
      myCells[i].removeAll();    
    delete [] myCells;
  }
}

Vector3D Grid3D::getResolution() const
{
  return Vector3D(myDimension[0], myDimension[1], myDimension[2]);
}

void Grid3D::setResolution(const Vector3D& res)
{
  myDimension[0] = (int)res.x();
  myDimension[1] = (int)res.y();
  myDimension[2] = (int)res.z();
  
  myAreCellsValid = false;                                
}

void Grid3D::setResolution(int x, int y, int z)
{
  myDimension[0] = x;
  myDimension[1] = y;
  myDimension[2] = z;

  myAreCellsValid = false;                                
}

void Grid3D::adoptObject(Object3D* newObject)
{
  myAreCellsValid = false;
  Aggregate3D::adoptObject(newObject);
}

int Grid3D::orphanObject(const Object3D* object)
{
  myAreCellsValid = false;
  return Aggregate3D::orphanObject(object);
}

int Grid3D::replaceObject(const Object3D* from, Object3D* to)
{
  myAreCellsValid = false;
  return Aggregate3D::replaceObject(from, to);
}

Aggregate3D* Grid3D::makeEmpty() const
{
  return new Grid3D;
}

Object3D* Grid3D::copy() const
{
  return new Grid3D(*this);
}

/*
 * Traverse grid and test if visited voxels are empty. If not, 
 * test objects in voxel for intersection;
 */
bool Grid3D::doIntersect(Ray3D& ray)
{
  // increase id of intersection. used for mailbox.
  intersectCallCounter++;
  
  // Grid has been initialized?
  if (!myAreCellsValid)
    initCells();
  //
  // compute intersection point of ray with grid and 
  // transform grid to obtain voxels of size 1.
  //
  Vector3D hit = ray.getOrigin();
  // test if ray origin is not inside grid
  if (!mySubBounds.inside(hit))
    hit += ray.getBoundsHitDistance()*ray.getDirection();

  // transform hit (shrink/expand all voxels to unit cubes)
  hit = transformAsPoint(hit, myToUnit);

  // transform direction of ray in the same way
  Vector3D rDir = transformAsVector(ray.getDirection(), myToUnit);

  rDir.normalize();

  //
  // Calculate position of hit in grid space
  //
  int pos[3];
  register int i;
  for (i=0; i<3; i++) // Current position in Grid
    pos[i] = boundsFloor(hit[i], 0, myDimension[i]-1);

  //cerr << "h: "<< hit <<", d: "<<rDir<< endl;;
  //
  // ... but now trouble starts!!
  // Offset of current intersection from origin of current voxel
  //
  Real deltaPos[3];
  Real absRDir[3];
  for (i=0; i<3;i++) { 
    deltaPos[i] = hit[i]-pos[i];
    // to speed up what follows ...
    absRDir[i] = fabs(rDir[i]);
  }

  // find driving (da) and passive axis (pa)
  int da, pa1, pa2;
  if (absRDir[0]>absRDir[1] && absRDir[0]>absRDir[2]) {
    da = 0; pa1 = 1; pa2 = 2; 
  } else if (absRDir[1]>absRDir[2]) {
    da = 1; pa1 = 0; pa2 = 2; 
  } else {
    da = 2; pa1 = 0; pa2 = 1; 
  }

  //
  // Test current cell (= cell of first intersection) for intersections 
  //
  if (intersectCell(pos, da,  ray)) 
    return true;		// Hey, that was easy ...



  Real iter[3], invIter[3];
  int deltaIter[3];
  Real tmp = absRDir[da];
  for (i=0; i<3; i++) {
    // Amount to go in one step: driving direction is 1, the other two <= 1
    iter[i] = rDir[i] / tmp;
    if (equal(iter[i],1)) 
      iter[i] = invIter[i] = 1.0;
    else if (equal(iter[i],-1)) 
      iter[i] = invIter[i] = -1.0;
    else if (equal(iter[i],0)) { 
      iter[i] = 0.0; invIter[i] = MAXREAL; 
    } else
      invIter[i] = 1/iter[i];
    // Possible changes in each direction for one step
    deltaIter[i] = sign(iter[i]);
  }

  // Be sure we are on a voxel border in driving axis direction
  if (!equal(deltaPos[da],0) && !equal(deltaPos[da],1)) {
    Real tmp = (rDir[da] < 0) ? deltaPos[da] : (1-deltaPos[da]);
    for (i=0; i<3; i++) 
      deltaPos[i] += iter[i]*tmp;
  } else
    for (i=0; i<3; i++) 
      deltaPos[i] += iter[i];

  int overflow1, overflow2, temp;
  Real t1, t2;
  while (true) {
    // test for overflow/underflow along passive axis
    overflow1 = deltaPos[pa1] >=1 || deltaPos[pa1] <= 0;
    overflow2 = deltaPos[pa2] >=1 || deltaPos[pa2] <= 0;
    if (overflow1 && overflow2) {
      t1 = 1-deltaPos[pa1]*invIter[pa1];
      t2 = 1-deltaPos[pa2]*invIter[pa2];
      if (deltaPos[pa1] >= 0)
	t1 += invIter[pa1];
      if (deltaPos[pa2] >= 0)
	t2 += invIter[pa2];
      if (fabs(t1) > fabs(t2)) {
	temp = overflow1; overflow1 = overflow2; overflow2 = temp;
	temp = pa1; pa1 = pa2; pa2 = temp;
      }
    }

    //cerr << "lpos: [" << pos[0]<<","<<pos[1]<<","<<pos[2]<<"][" << deltaPos[0]<<","<<deltaPos[1]<<","<<deltaPos[2]<<"]";
    if (overflow1) {
      pos[pa1] += deltaIter[pa1];
      // check for bounds of grid
      if (pos[pa1] < 0 || pos[pa1] >= myDimension[pa1]){
	//cerr << endl<< "##### case 0, pos: [" << pos[0]<<","<<pos[1]<<","<<pos[2]<<"]"<< endl;
        return false;		// we left grid
      }
      // test current cell for intersections 
      if (intersectCell(pos, da, ray)){
	//cerr << endl;
        return true;		// gotcha!
      }
      //cerr << "0";
      deltaPos[pa1] -= deltaIter[pa1];
    }
    
    if (overflow2) {
      pos[pa2] += deltaIter[pa2];
      // check for bounds of grid
      if (pos[pa2] < 0 || pos[pa2] >= myDimension[pa2]){
	//cerr << endl<< "##### case 1, pos: [" << pos[0]<<","<<pos[1]<<","<<pos[2]<<"]"<< endl;

        return false;		// we left grid
      }
      // test current cell for intersections 
      if (intersectCell(pos, da, ray)){
	//cerr << endl;

        return true;		// gotcha!
      }
      //cerr << "1";
      deltaPos[pa2] -= deltaIter[pa2];
    }

    // next voxel in driving axis direction
    pos[da] += deltaIter[da];
    // check for bounds of grid
    if (pos[da] < 0 || pos[da] >= myDimension[da]){
      //cerr << endl<< "##### case 2, pos: [" << pos[0]<<","<<pos[1]<<","<<pos[2]<<"]"<< endl;

      return false;		// we left grid
    }
    // test current cell for intersections 
    if (intersectCell(pos, da, ray)){
      //cerr << endl;

      return true;		// gotcha!
    }

    //cerr << "2"<<endl;

    // add iteration step along each axis to current position 
    for (i=0; i<3; i++) 
      deltaPos[i] += iter[i];
  }  
}

bool Grid3D::intersectCell(int pos[], int da, Ray3D& ray)
{
  // Some initialization
  bool foundIntersection = false;
  List<long>& objs = getCellList(pos[0], pos[1], pos[2]);
  long objCount = objs.count();

  // First lets see if there's anything to do at all ...
  if (objCount == 0) // no objects, no intersection
    return false;

  long curObj;              // cur object index
  
  Real oldHitDist, oldHitBoundsDist, oldTolerance;
  Vector3D hit;
  int curPos[3],i;
  //cerr <<"["<< pos[0]<<","<<pos[1]<<","<<pos[2]<<"]";
  for (long k=0; k<objCount; k++) { // forall objects in current voxel
    // look for any better (nearer) intersection than current
    curObj = objs.item(k);
    // current ray never tested against current object
    if (myMBox.getLastRay(curObj) != intersectCallCounter) {
 
      // store old state
      oldHitDist       = ray.getBestHitDistance();
      oldHitBoundsDist = ray.getBoundsHitDistance();
      oldTolerance     = ray.getTolerance();
      
      // found a better intersection !
      if (myElements.item(curObj)->intersect(ray)) {
        hit = transformAsPoint(ray.getHitPoint(), myToUnit);
	// cerr << "("<<k<<")";
        for (i=0; i<3; i++) 
          curPos[i]=boundsFloor(hit[i], 0, myDimension[i]-1);

        if (curPos[da]==pos[da]) {
	  if (curPos[(da+1)%3]!=pos[(da+1)%3])
	    cerr << "%";
	  if (curPos[(da+2)%3]!=pos[(da+2)%3])
	    cerr << "&";
          // if intersection point lies in current voxel,
          // we found a good candidate...
	  // cerr << "c("<< curPos[0]<<","<<curPos[1]<<","<<curPos[2]<<")("<<hit<<")";
          foundIntersection = true;
        } else {
	 // if intersection point lies NOT in current voxel, 
	 // there might be a nearer intersection with another object,
	 // so we have to wait 'til we're in the correct voxel
	 myMBox.setLastRay(curObj, intersectCallCounter);
	 myMBox.setDist(curObj, ray.getBestHitDistance());
	 myMBox.setBoundsDist(curObj, ray.getBoundsHitDistance());
	 myMBox.setTolerance(curObj, ray.getTolerance());
	 myMBox.setHit(curObj, ray.getBestHitObject());
	 myMBox.setCell(curObj, curPos);
	  
	 ray.setBestHitDistance(oldHitDist);
	 ray.setBoundsHitDistance(oldHitBoundsDist);
	 ray.setTolerance(oldTolerance);
	 //cerr << "w("<< curPos[0]<<","<<curPos[1]<<","<<curPos[2]<<")("<<hit<<")";
        }
      } else {
        // we didn't find a intersection with current object, 
        // so we never have to test this ray against this object
        myMBox.setLastRay(curObj, intersectCallCounter);
        int tmp[3] = { -1, -1, -1 };
        myMBox.setCell(curObj, tmp);
	//cerr << "n";
      }
    } else { // there has already been a intersection test between ray and object
      // Is the current position the same as the voxel in which the formerly
      // computed intersection point lies ?
      //cerr << "a";
      
      if (pos[da]==myMBox.getCell(curObj,da)){
	if (pos[(da+1)%3]!=myMBox.getCell(curObj,(da+1)%3))
	  cerr << "@";
	if (pos[(da+2)%3]!=myMBox.getCell(curObj,(da+2)%3))
	  cerr << "$";

	if (myMBox.getDist(curObj) < ray.getBestHitDistance()) { 
	  ray.setBestHitDistance(myMBox.getDist(curObj));
	  ray.setBoundsHitDistance(myMBox.getBoundsDist(curObj));
	  ray.setTolerance(myMBox.getTolerance(curObj));
	  ray.setBestHitObject(myMBox.getHit(curObj));
	  
	  foundIntersection = true;
	}
      } 
    }
  }
  
  return foundIntersection;
}

Makeable* Grid3D::make(RCString& errMsg, const List<Value*>* parameters) const
{
  checkParameterNumber(1);
  getParameter(1, Vector3D, dimension);
  
  if (dimension.x() < 1 || dimension.y() < 1 || dimension.z() < 1) {
    ostrstream os;
    os << "Illegal dimension settings " << dimension 
       << ", no component less than 1";
    errMsg = os;  
    return NULL;
  }
  
  return new Grid3D((int)rint(dimension.x()),
                    (int)rint(dimension.y()),
                    (int)rint(dimension.z()));
}

static const RCString grid3DKeyword("grid");

RCString Grid3D::getKeyword() const {
  return grid3DKeyword;
}

List<Value*>* Grid3D::createParameters() {
  List<Value*>* parameters = new List<Value*>;
  parameters->append(new Value(getResolution()));
  return parameters;
}

/*
 * Precondition:
 * -------------
 * It's asumed, that the bounding box of grid and the bounding 
 * boxes of all boxes have been initialized!
 */
void Grid3D::initCells()
{
  int i;
  long k;
  long size = countSubobject();
  mySubBounds.reset();

  if (myCells != NULL){
    for (long i = 0; i < myDimension[0]*myDimension[1]*myDimension[2]; i++)
      myCells[i].removeAll();    
    delete [] myCells;
  }

  myCells = new List<long>[myDimension[0]*myDimension[1]*myDimension[2]];

  // compute the bounding box without any transformation
  for (k=0; k<size; k++)
    mySubBounds.expand(getSubobject(k)->getBounds());

  // set voxel size in each axis
  for (i=0; i<3; i++)
    myExtension[i] = (mySubBounds.getMax()[i]-mySubBounds.getMin()[i]) / myDimension[i];

  // Build transformation matrix for scaling to standard grid with origin in bbox.min
  myToUnit =   TransMatrix3D::makeTranslate(-mySubBounds.getMin()) * 
               TransMatrix3D::makeScale(1/myExtension[0],1/myExtension[1],1/myExtension[2]);
  //cerr << "bounds:   " << mySubBounds << endl;
  //cerr << "myToUnit: " << myToUnit << endl;
  //cerr << "extesions:" << myExtension[0]<<","<<myExtension[1]<<","<<myExtension[2]<<endl;
  int x, y, z;
  int xmin, xmax, ymin, ymax, zmin, zmax;
  Vector3D min, max;
  Object3D* cur;

  for (k=0; k<size; k++) {
    cur = getSubobject(k);

    // initialize voxels :
    // for each voxel, that intersects the object's bounding box,
    // add pointer to this object to voxel's list.
    min = cur->getBounds().getMin() - mySubBounds.getMin();
    max = cur->getBounds().getMax() - mySubBounds.getMin();
    xmin = boundsFloor(min[0]/myExtension[0] - EPSILON, 0, myDimension[0]-1);
    xmax = boundsFloor(max[0]/myExtension[0] + EPSILON, 0, myDimension[0]-1);
    ymin = boundsFloor(min[1]/myExtension[1] - EPSILON, 0, myDimension[1]-1);
    ymax = boundsFloor(max[1]/myExtension[1] + EPSILON, 0, myDimension[1]-1);
    zmin = boundsFloor(min[2]/myExtension[2] - EPSILON, 0, myDimension[2]-1);
    zmax = boundsFloor(max[2]/myExtension[2] + EPSILON, 0, myDimension[2]-1);
    
    //cerr << k << " : ["<< xmin << ","<< xmax <<"] ["
    //                   << ymin << ","<< ymax <<"] ["
    //                   << zmin << ","<< zmax <<"]"<<endl;

    for (x=xmin; x<=xmax; x++)
      for (y=ymin; y<=ymax; y++)
	for (z=zmin; z<=zmax; z++)
	  getCellList(x,y,z).append(k);

  }

  // Initialize Mailbox to proper size
  myMBox.setSize(size);
  myAreCellsValid = true;
}
//______________________________________________________________ Grid3D::Mailbox
 
Grid3D::Mailbox::Mailbox()
{
  mySize  = 0;
  myEntry = NULL;
}
 
Grid3D::Mailbox::Mailbox(const Mailbox& mbox)
{
  myEntry = new Entry[mbox.mySize];
  mySize  = mbox.mySize;
 
  // initialize data
  for (long k=0; k<mySize; k++) 
    myEntry[k].myLastRay = 0;
}
 
Grid3D::Mailbox::~Mailbox()
{
  delete myEntry;
}
 
void Grid3D::Mailbox::setSize(long size)
{
  if (size <= 0) {
    ostrstream os;
    os << "[Grid3D::Mailbox::setSize] Illegal size (was ";
    os << size << ")";
 
    Report::recoverable(os);
    return;
  }
  
  delete myEntry;
  
  mySize  = size;
  myEntry = new Entry[mySize];
 
  // initialize data
  for (long k=0; k<mySize; k++) 
    myEntry[k].myLastRay = 0;
}
