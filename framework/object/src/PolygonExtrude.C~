/*
 * PolygonExtrude.C
 *
 * Copyright (C) 1996, Thierry Matthey <matthey@iam.unibe.ch>
 *                     University of Berne, Switzerland
 *
 * All rights reserved.
 *
 * This software may be freely copied, modified, and redistributed
 * provided that this copyright notice is preserved on all copies.
 *
 * You may not distribute this software, in whole or in part, as part of
 * any commercial product without the express consent of the authors.
 *
 * There is no warranty or other guarantee of fitness of this software
 * for any purpose.  It is provided solely "as is".
 *
 * -----------------------------------------------------------------------------
 *  $Id: PolygonExtrude.C,v 1.11 1997/01/17 09:46:26 matthey Exp $
 * -----------------------------------------------------------------------------
 */

#include <strstream.h>

#include "booga/base/Value.h"
#include "booga/base/Geometry3D.h"
#include "booga/object/Shared3D.h"
#include "booga/object/Grid3D.h"
#include "booga/object/Polygon3D.h"
#include "booga/object/PolygonExtrude.h"
#include "booga/object/PolygonExtrudeAttr.h"
#include "booga/object/MakeableHandler.h"
#include "booga/object/DummyMakeable.h"

// ____________________________________________________________________ PolygonExtrude

implementRTTI(PolygonExtrude, Primitive3D);

PolygonExtrude::PolygonExtrude(Exemplar exemplar)
: Primitive3D(exemplar)
{
  myDecomposition = NULL;
  myHeight = 0;
}

PolygonExtrude::PolygonExtrude(Real height, const List<Vector3D>& vertices, const List<List<Vector3D> >& holes)
: myVertices(vertices)
{
  for(long i=0; i<holes.count(); i++)
    addHole(holes.item(i));

  myDecomposition = NULL;
  myHeight = height;
}

PolygonExtrude::PolygonExtrude(Real height, const List<Vector3D>& vertices, const List<Vector3D>& hole)
: myVertices(vertices)
{
  addHole(hole);

  myDecomposition = NULL;
  myHeight = height;
}

PolygonExtrude::PolygonExtrude(const PolygonExtrude& poly)
: myVertices(poly.myVertices),myHoles(poly.myHoles)
{
  myDecomposition = NULL;
  myHeight = poly.myHeight;
}

PolygonExtrude::~PolygonExtrude()
{
  delete myDecomposition;
}

void PolygonExtrude::addVertex(const Vector3D& vertex)
{
  long count = myVertices.count();

  //
  // Check for valid vertex.
  //
  if (count > 0) {
    if (myVertices.item(count-1) == vertex) {
      ostrstream os;
      os << "[PolygonExtrude::addVertex] two consecutive vertices ("
         << vertex << ") must not have the same value";
      Report::recoverable(os);
      return;
    }
  }

  if (myDecomposition != NULL) {
    delete myDecomposition;
    myDecomposition = NULL;
  }
  
  myVertices.append(vertex);
}

Object3D* PolygonExtrude::createDecomposition() const
{
  //
  // We already have a valid decomposition of the polygon object -> just make a copy.
  //
  if (myDecomposition != NULL)
    return myDecomposition->copy();
    
  long count = myVertices.count();
  if (count < 3) {
    Report::warning("[PolygonExtrude::createDecomposition] degenerate polygon");
    return NULL;
  }

  Grid3D* polyeder = new Grid3D(15,15,15);

  List<Vector3D> bottom(count), top(count), side(4), vertices(count);
  long i, j;
  
  if (Geometry3D::normal(myVertices).z()>0)
    vertices = myVertices; // Anti-clockwise.
  else 
    for (i=0; i<count; i++)         // Clockwise -> rearrange.
      vertices.prepend(myVertices.item(i));
  
  if (myHeight > 0) {
    for (i=0; i<count; i++){
      top.append(Vector3D(vertices.item(i).x(),
                          vertices.item(i).y(),
                          vertices.item(i).z() + myHeight));
      bottom.prepend(vertices.item(i));
    }
    
    //
    // The faces around the base polygon
    //                      
    for (i=0; i< count; i++) {
      side.removeAll();
      side.append(vertices.item(i));
      side.append(vertices.item((i+1) % count));
      side.append(top.item((i+1) % count));
      side.append(top.item(i));    
      polyeder->adoptObject(new Polygon3D(side));
    }
    //
    // The faces of the holes
    //
    for (i=0; i<myHoles.count(); i++)
      if (Geometry3D::normal(myHoles.item(i)).z() < 0 )
        for (j=0; j<myHoles.item(i).count();j++){
          side.removeAll();
          side.append(myHoles.item(i).item(j));
          side.append(myHoles.item(i).item((j+1) % myHoles.item(i).count()));
          side.append(myHoles.item(i).item((j+1) % myHoles.item(i).count()) +  Vector3D(0,0,myHeight));
          side.append(myHoles.item(i).item(j)+  Vector3D(0,0,myHeight));    
          polyeder->adoptObject(new Polygon3D(side));      
       }
      else
        for (j=0; j<myHoles.item(i).count();j++){
          side.removeAll();
          side.prepend(myHoles.item(i).item(j));
          side.prepend(myHoles.item(i).item((j+1) % myHoles.item(i).count()));
          side.prepend(myHoles.item(i).item((j+1) % myHoles.item(i).count()) +  Vector3D(0,0,myHeight));
          side.prepend(myHoles.item(i).item(j)+  Vector3D(0,0,myHeight));    
          polyeder->adoptObject(new Polygon3D(side));      
       }
    //
    // The top polygon of the polyeder
    
    if (myHoles.count() > 0) {
      List<Vector3D> tmp1;
      List<List<Vector3D> > tmp2;
      for (i=0; i<myHoles.count(); i++){
        tmp1.removeAll();  
        for (j=0; j<myHoles.item(i).count(); j++)
          tmp1.append(myHoles.item(i).item(j)+ Vector3D(0,0,myHeight));
        tmp2.append(tmp1);
      }
      polyeder->adoptObject(new Polygon3D(top, tmp2));
    }                         
    else
      polyeder->adoptObject(new Polygon3D(top));
  }
  else
    Report::warning("[PolygonExtrude::createDecomposition] height not positive");  
  
  //
  // The base polygon of the polyeder
  //
  polyeder->adoptObject(new Polygon3D(bottom, myHoles));

  ((PolygonExtrude*)this)->myDecomposition = new Shared3D(polyeder);
  ((PolygonExtrude*)this)->myDecomposition->computeBounds();
  return myDecomposition->copy();
}

Object3D* PolygonExtrude::copy() const
{
  return new PolygonExtrude(*this);
}

bool PolygonExtrude::doIntersect(Ray3D& ray)
{
  if (myDecomposition == NULL)
    delete PolygonExtrude::createDecomposition();

  return myDecomposition->intersect(ray);
}

Vector3D PolygonExtrude::normal(const Vector3D&) const
{
  return Vector3D(0,0,1); // !!!!!!! TO DO !!!!!!!
}

void PolygonExtrude::doComputeBounds()
{
  register long i, j;
  for (i=0; i<myVertices.count(); i++) {
    myBounds.expand(myVertices.item(i));
    myBounds.expand(Vector3D(myVertices.item(i).x(),
                             myVertices.item(i).y(),
                             myVertices.item(i).z() + myHeight));
   }                         
  for (i=0; i<myHoles.count(); i++)
    for (j=0; j<myHoles.item(i).count(); j++) {
      myBounds.expand(myHoles.item(i).item(j));
      myBounds.expand(myHoles.item(i).item(j) + Vector3D(0,0,myHeight));
   }                         
}
  
Makeable* PolygonExtrude::make(RCString& errMsg, const List<Value*>* parameters) const
{
  PolygonExtrude* newPolygon = new PolygonExtrude(*this);

  getParameter(1, Real, height);
  newPolygon->setHeight(height);
  newPolygon->removeVertices();

  for (int i=2; i<=parameters->count(); i++) {
    getParameter(i, Vector3D, vertex);
    newPolygon->addVertex(vertex);
  }
    
  return newPolygon;
}

int PolygonExtrude::setSpecifier(RCString& errMsg, Makeable* specifier)
{
  // Check for PolygonExtrude attributes
  PolygonExtrudeAttr* attr = dynamic_cast(PolygonExtrudeAttr, specifier);
  if (attr != NULL) {
    // The PolygonExtrude object knows best which method has to be called.
    // So let the object do the job.

    attr->setAttribute(this);
     
    delete attr;
    return 1;  
  }
  
  // 
  // Let papa do the rest ...
  //
  return Primitive3D::setSpecifier(errMsg, specifier);
}

void PolygonExtrude::addHole(const List<Vector3D>& hole) 
{
  if (hole.count()>2)
    myHoles.append(hole);
  else {
    ostrstream os;
    os << "[PolygonExtrude::addHole] hole has less then 3 vertices ";
    Report::recoverable(os);
    return;
  }
}

static const RCString polygonExtrudeKeyword("polyextrude");

RCString PolygonExtrude::getKeyword() const {
  return polygonExtrudeKeyword;
}

List<Value*>* PolygonExtrude::createParameters() {
  List<Value*>* parameters = new List<Value*>;
  parameters->append(new Value(getHeight()));
  for (long i=0; i<getVertices().count(); i++) {
    parameters->append(new Value(getVertices().item(i)));
  }
  return parameters;
}

void PolygonExtrude::iterateAttributes(MakeableHandler* handler) {
  this->Object3D::iterateAttributes(handler);
  for (int i=0; i<myHoles.count(); i++) {
    DummyMakeable hole("hole");
    for (int j=0; j<myHoles.item(i).count(); j++) {
      hole.addParameter(Value(myHoles.item(i).item(j)));
    }
    handler->handle(&hole);
  }
}
